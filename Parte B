///Daniela Dianne López Polanco
//PARTE B Servo
/// 5 posiciones posibles: 0°, 45°, 90°, 135°, 180°


#include <Arduino.h>   
#include <driver/ledc.h> 

// Pines
#define PIN_SERVO       18  // Pin donde está conectado el servo
#define BOTON_DERECHA   15  // Botón que mueve a la derecha (+45°)
#define BOTON_IZQUIERDA  4  // Botón que mueve a la izquierda (-45°)

// Configuración PWM
#define CANAL_PWM_SERVO  0   // Canal de PWM asignado al servo
#define FRECUENCIA_PWM  50   // Frecuencia del PWM (50 Hz, periodo de 20 ms)
#define RESOLUCION_PWM  16   // Resolución de PWM (16 bits → 0..65535)

// Límites del pulso para el servo (en microsegundos)
#define PULSO_MIN_US   600   // Pulso para 0°
#define PULSO_MAX_US  2400   // Pulso para 180°

static const uint16_t ANGULOS[5] = {0, 45, 90, 135, 180}; // Posiciones fijas
uint8_t posicionActual = 2; // Empieza en 90° (índice 2 del arreglo)

// Variables para guardar estado previo de botones (antirrebote)
bool estadoPrevioDerecha = false;
bool estadoPrevioIzquierda = false;

//  Prototipos
// Convierte un ángulo a microsegundos
static inline uint16_t anguloAMicroseg(uint16_t angulo);
// Convierte microsegundos a valor de duty cycle
static inline uint32_t microsegADuty(uint16_t microseg);
// Mueve el servo a un ángulo específico
static void moverServo(uint16_t angulo);
// Configura el canal de PWM
static void iniciarPWM(void);

// Setup 
void setup() {
  Serial.begin(115200); // Inicia comunicación serie para depuración

  // Configuración de pines como entrada con resistencia pull-up
  pinMode(BOTON_DERECHA, INPUT_PULLUP);
  pinMode(BOTON_IZQUIERDA, INPUT_PULLUP);

  iniciarPWM(); // Inicializa el PWM para el servo
  moverServo(ANGULOS[posicionActual]); // Coloca el servo en la posición inicial
}

// Loop 
void loop() {
  // Lee botones (activos en LOW por pull-up)
  bool presionadoDerecha = !digitalRead(BOTON_DERECHA);
  bool presionadoIzquierda = !digitalRead(BOTON_IZQUIERDA);

  // Si se presionó el botón de la derecha (y antes no estaba presionado)
  if (presionadoDerecha && !estadoPrevioDerecha) {
    if (posicionActual < 4) posicionActual++; // Avanza a la siguiente posición
    moverServo(ANGULOS[posicionActual]);
    Serial.printf("Derecha -> Posición: %u°\n", ANGULOS[posicionActual]);
  }
  estadoPrevioDerecha = presionadoDerecha; // Actualiza estado

  // Si se presionó el botón de la izquierda
  if (presionadoIzquierda && !estadoPrevioIzquierda) {
    if (posicionActual > 0) posicionActual--; // Retrocede a la posición anterior
    moverServo(ANGULOS[posicionActual]);
    Serial.printf("Izquierda -> Posición: %u°\n", ANGULOS[posicionActual]);
  }
  estadoPrevioIzquierda = presionadoIzquierda; // Actualiza estado

  delay(40); // Pausa corta para antirrebote
}

// Funciones 

// Configura el canal de PWM para controlar el servo
static void iniciarPWM(void) {
  ledcSetup(CANAL_PWM_SERVO, FRECUENCIA_PWM, RESOLUCION_PWM);
  ledcAttachPin(PIN_SERVO, CANAL_PWM_SERVO);
}

// Convierte un ángulo (0°..180°) a su pulso correspondiente en microsegundos
static inline uint16_t anguloAMicroseg(uint16_t angulo) {
  return PULSO_MIN_US + ((uint32_t)(PULSO_MAX_US - PULSO_MIN_US) * angulo) / 180U;
}

// Convierte microsegundos a un valor de duty cycle para el PWM
static inline uint32_t microsegADuty(uint16_t microseg) {
  const uint32_t dutyMax = (1UL << RESOLUCION_PWM) - 1UL;
  return ((uint64_t)microseg * FRECUENCIA_PWM * dutyMax) / 1000000ULL;
}

// Mueve el servo a un ángulo dado
static void moverServo(uint16_t angulo) {
  uint16_t microseg = anguloAMicroseg(angulo); // Calcula pulso
  uint32_t duty = microsegADuty(microseg);     // Calcula duty
  ledcWrite(CANAL_PWM_SERVO, duty);            // Aplica el duty al canal
}
